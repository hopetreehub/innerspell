name: CD Pipeline - Continuous Deployment

on:
  # Auto-deploy to staging on develop branch
  push:
    branches: 
      - develop
      - main
  # Manual deployment trigger
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        type: choice
        options:
          - staging
          - production
      skip_tests:
        description: 'Skip smoke tests'
        required: false
        type: boolean
        default: false

env:
  VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
  VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
  NODE_VERSION: '20'

jobs:
  # Determine deployment environment
  setup:
    name: Setup Deployment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.determine.outputs.environment }}
      url_prefix: ${{ steps.determine.outputs.url_prefix }}
      needs_approval: ${{ steps.determine.outputs.needs_approval }}
    steps:
      - name: Determine environment
        id: determine
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/develop" ]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "environment=production" >> $GITHUB_OUTPUT
          fi
          
          # Set URL prefix based on environment
          if [ "${{ steps.determine.outputs.environment }}" = "staging" ]; then
            echo "url_prefix=staging-" >> $GITHUB_OUTPUT
            echo "needs_approval=false" >> $GITHUB_OUTPUT
          else
            echo "url_prefix=" >> $GITHUB_OUTPUT
            echo "needs_approval=true" >> $GITHUB_OUTPUT
          fi

  # Deploy to Vercel
  deploy:
    name: Deploy to ${{ needs.setup.outputs.environment }}
    runs-on: ubuntu-latest
    needs: [setup]
    environment: 
      name: ${{ needs.setup.outputs.environment }}
      url: ${{ steps.deploy.outputs.url }}
    outputs:
      url: ${{ steps.deploy.outputs.url }}
      deployment_id: ${{ steps.deploy.outputs.deployment_id }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install Vercel CLI
        run: npm install -g vercel@latest

      - name: Pull Vercel environment information
        run: |
          if [ "${{ needs.setup.outputs.environment }}" = "production" ]; then
            vercel pull --yes --environment=production --token=${{ secrets.VERCEL_TOKEN }}
          else
            vercel pull --yes --environment=preview --token=${{ secrets.VERCEL_TOKEN }}
          fi

      - name: Build project artifacts
        run: |
          if [ "${{ needs.setup.outputs.environment }}" = "production" ]; then
            vercel build --prod --token=${{ secrets.VERCEL_TOKEN }}
          else
            vercel build --token=${{ secrets.VERCEL_TOKEN }}
          fi

      - name: Deploy to Vercel
        id: deploy
        run: |
          if [ "${{ needs.setup.outputs.environment }}" = "production" ]; then
            DEPLOYMENT_URL=$(vercel deploy --prebuilt --prod --token=${{ secrets.VERCEL_TOKEN }} | tail -1)
          else
            DEPLOYMENT_URL=$(vercel deploy --prebuilt --token=${{ secrets.VERCEL_TOKEN }} | tail -1)
          fi
          echo "url=$DEPLOYMENT_URL" >> $GITHUB_OUTPUT
          echo "deployment_id=${DEPLOYMENT_URL##*/}" >> $GITHUB_OUTPUT
          echo "Deployed to: $DEPLOYMENT_URL"

      - name: Create deployment status
        uses: actions/github-script@v7
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: '${{ needs.setup.outputs.environment }}',
              auto_merge: false,
              required_contexts: [],
              production_environment: '${{ needs.setup.outputs.environment }}' === 'production'
            });
            
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deployment.data.id,
              state: 'success',
              environment_url: '${{ steps.deploy.outputs.url }}',
              description: 'Deployment completed successfully'
            });

  # Smoke tests after deployment
  smoke-tests:
    name: Post-deployment Smoke Tests
    runs-on: ubuntu-latest
    needs: [deploy, setup]
    if: ${{ github.event.inputs.skip_tests != 'true' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install Playwright browsers
        run: npx playwright install --with-deps chromium

      - name: Wait for deployment to be ready
        run: |
          echo "Waiting for deployment to be ready..."
          for i in {1..30}; do
            if curl -f -s "${{ needs.deploy.outputs.url }}" > /dev/null; then
              echo "Deployment is ready!"
              break
            fi
            echo "Attempt $i/30: Deployment not ready yet..."
            sleep 10
          done

      - name: Run smoke tests
        run: |
          cat > smoke-tests.spec.ts << 'EOF'
          import { test, expect } from '@playwright/test';

          const deploymentUrl = '${{ needs.deploy.outputs.url }}';

          test.describe('Deployment Smoke Tests', () => {
            test('Homepage loads successfully', async ({ page }) => {
              const response = await page.goto(deploymentUrl);
              expect(response?.status()).toBeLessThan(400);
              await expect(page).toHaveTitle(/InnerSpell/);
            });

            test('API health check passes', async ({ request }) => {
              const response = await request.get(`${deploymentUrl}/api/health`);
              expect(response.ok()).toBeTruthy();
              const data = await response.json();
              expect(data.status).toBe('healthy');
            });

            test('Critical pages are accessible', async ({ page }) => {
              const criticalPaths = ['/about', '/tarot', '/blog'];
              
              for (const path of criticalPaths) {
                const response = await page.goto(`${deploymentUrl}${path}`);
                expect(response?.status()).toBeLessThan(400);
              }
            });

            test('No console errors on homepage', async ({ page }) => {
              const errors: string[] = [];
              page.on('console', (msg) => {
                if (msg.type() === 'error') {
                  errors.push(msg.text());
                }
              });

              await page.goto(deploymentUrl);
              await page.waitForLoadState('networkidle');
              
              expect(errors).toHaveLength(0);
            });
          });
          EOF
          
          npx playwright test smoke-tests.spec.ts --reporter=list

      - name: Upload test results
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: smoke-test-results
          path: |
            playwright-report/
            test-results/
          retention-days: 7

  # Health check monitoring
  health-check:
    name: Deployment Health Check
    runs-on: ubuntu-latest
    needs: [deploy, smoke-tests]
    if: always() && needs.deploy.result == 'success'
    steps:
      - name: Monitor deployment health
        run: |
          DEPLOYMENT_URL="${{ needs.deploy.outputs.url }}"
          
          echo "üîç Checking deployment health..."
          
          # Performance check
          RESPONSE_TIME=$(curl -o /dev/null -s -w '%{time_total}' "$DEPLOYMENT_URL")
          echo "Response time: ${RESPONSE_TIME}s"
          
          # Status check
          HTTP_STATUS=$(curl -o /dev/null -s -w '%{http_code}' "$DEPLOYMENT_URL")
          echo "HTTP Status: $HTTP_STATUS"
          
          # API health check
          API_HEALTH=$(curl -s "$DEPLOYMENT_URL/api/health" | jq -r '.status' || echo "failed")
          echo "API Health: $API_HEALTH"
          
          # Determine overall health
          if [ "$HTTP_STATUS" = "200" ] && [ "$API_HEALTH" = "healthy" ]; then
            echo "‚úÖ Deployment is healthy!"
            exit 0
          else
            echo "‚ùå Deployment health check failed!"
            exit 1
          fi

  # Send notifications
  notify:
    name: Send Deployment Notifications
    runs-on: ubuntu-latest
    needs: [deploy, setup, smoke-tests, health-check]
    if: always()
    steps:
      - name: Prepare notification message
        id: message
        run: |
          ENVIRONMENT="${{ needs.setup.outputs.environment }}"
          URL="${{ needs.deploy.outputs.url }}"
          STATUS="unknown"
          EMOJI="‚ùì"
          
          if [ "${{ needs.health-check.result }}" = "success" ]; then
            STATUS="successful"
            EMOJI="‚úÖ"
          elif [ "${{ needs.health-check.result }}" = "failure" ]; then
            STATUS="failed"
            EMOJI="‚ùå"
          elif [ "${{ needs.deploy.result }}" = "success" ]; then
            STATUS="deployed (health check skipped)"
            EMOJI="‚ö†Ô∏è"
          else
            STATUS="failed"
            EMOJI="‚ùå"
          fi
          
          echo "status=$STATUS" >> $GITHUB_OUTPUT
          echo "emoji=$EMOJI" >> $GITHUB_OUTPUT

      - name: Send Slack notification
        if: vars.SLACK_WEBHOOK_URL != ''
        uses: slackapi/slack-github-action@v1.24.0
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        with:
          payload: |
            {
              "text": "${{ steps.message.outputs.emoji }} Deployment to ${{ needs.setup.outputs.environment }} ${{ steps.message.outputs.status }}",
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "${{ steps.message.outputs.emoji }} Deployment Notification"
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Environment:*\n${{ needs.setup.outputs.environment }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Status:*\n${{ steps.message.outputs.status }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Branch:*\n${{ github.ref_name }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Commit:*\n${{ github.sha }}"
                    }
                  ]
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Deployment URL:*\n<${{ needs.deploy.outputs.url }}|View Deployment>"
                  }
                },
                {
                  "type": "context",
                  "elements": [
                    {
                      "type": "mrkdwn",
                      "text": "Triggered by: ${{ github.actor }} | <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Workflow>"
                    }
                  ]
                }
              ]
            }

      - name: Send Discord notification
        if: vars.DISCORD_WEBHOOK_URL != ''
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          curl -H "Content-Type: application/json" \
            -d '{
              "embeds": [{
                "title": "${{ steps.message.outputs.emoji }} Deployment to ${{ needs.setup.outputs.environment }}",
                "description": "Status: **${{ steps.message.outputs.status }}**",
                "color": ${{ steps.message.outputs.status == 'successful' && '3066993' || '15158332' }},
                "fields": [
                  {
                    "name": "Environment",
                    "value": "${{ needs.setup.outputs.environment }}",
                    "inline": true
                  },
                  {
                    "name": "Branch",
                    "value": "${{ github.ref_name }}",
                    "inline": true
                  },
                  {
                    "name": "Deployment URL",
                    "value": "[${{ needs.deploy.outputs.url }}](${{ needs.deploy.outputs.url }})"
                  }
                ],
                "footer": {
                  "text": "Triggered by ${{ github.actor }}"
                },
                "timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%S.000Z)'"
              }]
            }' \
            $DISCORD_WEBHOOK_URL

  # Rollback mechanism
  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    needs: [deploy, setup, health-check]
    if: failure() && needs.health-check.result == 'failure'
    steps:
      - name: Install Vercel CLI
        run: npm install -g vercel@latest

      - name: Get previous deployment
        id: previous
        run: |
          # Get list of deployments
          DEPLOYMENTS=$(vercel list --token=${{ secrets.VERCEL_TOKEN }} --scope=${{ secrets.VERCEL_ORG_ID }} --json)
          
          # Find the previous successful deployment
          PREVIOUS_URL=$(echo $DEPLOYMENTS | jq -r '.deployments[] | select(.state == "READY" and .target == "${{ needs.setup.outputs.environment }}") | .url' | sed -n '2p')
          
          if [ -z "$PREVIOUS_URL" ]; then
            echo "No previous deployment found for rollback"
            exit 1
          fi
          
          echo "previous_url=$PREVIOUS_URL" >> $GITHUB_OUTPUT

      - name: Promote previous deployment
        if: steps.previous.outputs.previous_url != ''
        run: |
          echo "üîÑ Rolling back to previous deployment: ${{ steps.previous.outputs.previous_url }}"
          
          if [ "${{ needs.setup.outputs.environment }}" = "production" ]; then
            vercel promote ${{ steps.previous.outputs.previous_url }} --token=${{ secrets.VERCEL_TOKEN }} --scope=${{ secrets.VERCEL_ORG_ID }}
          else
            echo "Rollback for staging environment - promoting previous deployment"
            vercel alias set ${{ steps.previous.outputs.previous_url }} staging-${{ secrets.VERCEL_PROJECT_NAME }}.vercel.app --token=${{ secrets.VERCEL_TOKEN }} --scope=${{ secrets.VERCEL_ORG_ID }}
          fi

      - name: Notify rollback
        if: steps.previous.outputs.previous_url != ''
        run: |
          echo "‚ö†Ô∏è Automatic rollback completed!"
          echo "Rolled back to: ${{ steps.previous.outputs.previous_url }}"